'use strict';

const { HttpsError, onCall } = require('firebase-functions/v2/https');
const { wrap } = require('../common/wrap');
const { httpWrap } = require('../common/http-wrap');
const { auth } = require('../common/auth');
const { admin, db } = require('../utils/firebaseAdmin');
const { callGenerativeModel } = require('../services/gemini');
const { fetchNaverNews, compressNewsWithAI, formatNewsForPrompt, shouldFetchNews } = require('../services/news-fetcher');
const { generateEnhancedMetadataHints } = require('../utils/enhanced-metadata-hints');
const { buildTitlePrompt } = require('../prompts/builders/title-generation');
const { buildSmartPrompt } = require('../prompts/prompts');

/**
 * 공백 제외 글자수 계산 (Java 코드와 동일한 로직)
 * @param {string} str - 계산할 문자열
 * @returns {number} 공백을 제외한 글자수
 */
function countWithoutSpace(str) {
  if (!str) return 0;
  let count = 0;
  for (let i = 0; i < str.length; i++) {
    if (!/\s/.test(str.charAt(i))) { // 공백 문자가 아닌 경우
      count++;
    }
  }
  return count;
}

/**
 * Bio 메타데이터를 기반으로 개인화된 원고 작성 힌트를 생성합니다
 * @param {Object} bioMetadata - 추출된 바이오그래피 메타데이터
 * @returns {string} 개인화 힌트 문자열
 */
function generatePersonalizedHints(bioMetadata) {
  if (!bioMetadata) return '';

  const hints = [];

  // 정치적 성향 기반 힌트
  if (bioMetadata.politicalStance?.progressive > 0.7) {
    hints.push('보수보다 혁신을 강조하는 진보적 관점으로 작성');
  } else if (bioMetadata.politicalStance?.conservative > 0.7) {
    hints.push('안정성과 전통 가치를 중시하는 보수적 관점으로 작성');
  } else if (bioMetadata.politicalStance?.moderate > 0.8) {
    hints.push('균형잡힌 중도적 관점에서 다양한 의견을 수용하여 작성');
  }

  // 소통 스타일 기반 힌트
  const commStyle = bioMetadata.communicationStyle;
  if (commStyle?.tone === 'warm') {
    hints.push('따뜻하고 친근한 어조 사용');
  } else if (commStyle?.tone === 'formal') {
    hints.push('격식있고 전문적인 어조 사용');
  }

  if (commStyle?.approach === 'inclusive') {
    hints.push('모든 계층을 포용하는 수용적 표현');
  } else if (commStyle?.approach === 'collaborative') {
    hints.push('협력과 소통을 강조하는 협업적 표현');
  }

  // 정책 관심도 기반 힌트
  const topPolicy = Object.entries(bioMetadata.policyFocus || {})
    .sort(([,a], [,b]) => b.weight - a.weight)[0];

  if (topPolicy && topPolicy[1].weight > 0.6) {
    const policyNames = {
      economy: '경제정책',
      education: '교육정책',
      welfare: '복지정책',
      environment: '환경정책',
      security: '안보정책',
      culture: '문화정책'
    };
    hints.push(`${policyNames[topPolicy[0]] || topPolicy[0]} 관점에서 표현`);
  }

  // 지역 연결성 기반 힌트
  if (bioMetadata.localConnection?.strength > 0.8) {
    hints.push('지역현안과 주민들의 실제 경험을 구체적으로 반영');
    if (bioMetadata.localConnection.keywords?.length > 0) {
      hints.push(`지역 용어 사용: ${bioMetadata.localConnection.keywords.slice(0, 3).join(', ')}`);
    }
  }

  // 생성 선호도 기반 힌트
  const prefs = bioMetadata.generationProfile?.likelyPreferences;
  if (prefs?.includePersonalExperience > 0.8) {
    hints.push('개인적 경험과 사례를 풍부하게 포함');
  }
  if (prefs?.useStatistics > 0.7) {
    hints.push('구체적인 숫자와 데이터를 적극적으로 사용');
  }
  if (prefs?.focusOnFuture > 0.7) {
    hints.push('미래 비전과 발전 방향을 제시');
  }

  return hints.join(' | ');
}

/**
 * 사용자 개인정보를 기반으로 페르소나 힌트를 생성합니다
 * @param {Object} userProfile - 사용자 프로필 정보
 * @param {string} category - 글 카테고리
 * @param {string} topic - 글 주제
 * @returns {string} 페르소나 힌트 문자열
 */
function generatePersonaHints(userProfile, category, topic) {
  if (!userProfile) return '';

  const hints = [];
  const topicLower = topic ? topic.toLowerCase() : '';

  // 카테고리별 관련도 높은 정보 우선 선택
  const relevantInfo = getRelevantPersonalInfo(userProfile, category, topicLower);

  // 선택된 정보만 자연스럽게 구성
  if (relevantInfo.age) {
    hints.push(relevantInfo.age);
  }

  if (relevantInfo.family) {
    hints.push(relevantInfo.family);
  }

  if (relevantInfo.background) {
    hints.push(relevantInfo.background);
  }

  if (relevantInfo.experience) {
    hints.push(relevantInfo.experience);
  }

  if (relevantInfo.committees && relevantInfo.committees.length > 0) {
    hints.push(`${relevantInfo.committees.join(', ')} 활동 경험을 바탕으로`);
  }

  if (relevantInfo.connection) {
    hints.push(relevantInfo.connection);
  }

  // X(트위터) 프리미엄 구독 시에는 SNS 본문 글자수 제한 체크 안하므로 페르소나에 반영 안함

  const persona = hints.filter(h => h).join(' ');
  return persona ? `[작성 관점: ${persona}]` : '';
}

/**
 * 글 카테고리와 주제에 따라 관련성 높은 개인정보만 선별합니다
 */
function getRelevantPersonalInfo(userProfile, category, topicLower) {
  const result = {};

  // 나이대 (일상 소통, 가정/육아 관련 주제에서 관련성 높음)
  if (category === 'daily-communication' ||
      topicLower.includes('family') || topicLower.includes('youth') || topicLower.includes('romance')) {
    if (userProfile.ageDecade) {
      result.age = userProfile.ageDetail ?
        `${userProfile.ageDecade} ${userProfile.ageDetail}` : userProfile.ageDecade;
    }
  }

  // 가정 상황 (교육, 복지, 일상 소통에서 관련성 높음)
  if (category === 'daily-communication' ||
      topicLower.includes('교육') || topicLower.includes('육아') || topicLower.includes('복지')) {
    if (userProfile.familyStatus) {
      const familyMap = {
        '아이없음': '자녀가 없는 부모로서',
        '자녀동반': '자녀 양육 가정의 경험을 가진',
        '기혼': '가정을 꾸리며',
        '미혼': '싱글 파트너로서'
      };
      result.family = familyMap[userProfile.familyStatus];
    }
  }

  // 배경 경력 (관련 정책 분야에서 관련성 높음)
  if (userProfile.backgroundCareer) {
    const careerRelevance = {
      '교육자': ['교육', '학생', '학교', '교사'],
      '사업가': ['경제', '중소상공인', '영업', '창업'],
      '공무원': ['행정', '정책', '공공서비스'],
      '의료인': ['의료', '건강', '코로나', '보건'],
      '법조인': ['법', '제도', '정의', '권리']
    };

    const relevantKeywords = careerRelevance[userProfile.backgroundCareer] || [];
    const isRelevant = relevantKeywords.some(keyword => topicLower.includes(keyword));

    if (isRelevant) {
      result.background = `${userProfile.backgroundCareer} 출신으로`;
    }
  }

  // 정치 경험 (의정활동 보고, 정책 제안에서 관련성 높음)
  if (category === 'activity-report' || category === 'policy-proposal') {
    if (userProfile.politicalExperience) {
      const expMap = {
        '초선': '초선 의원으로서 신선한 관점에서',
        '재선': '의정 경험을 바탕으로',
        '3선이상': '다선 의정 경험으로',
        '정치 신인': '새로운 시각에서'
      };
      result.experience = expMap[userProfile.politicalExperience];
    }
  }

  // 소속 위원회 (관련 분야에서만 언급)
  if (userProfile.committees && userProfile.committees.length > 0) {
    const validCommittees = userProfile.committees.filter(c => c && c !== '');
    const relevantCommittees = validCommittees.filter(committee => {
      const committeeKeywords = {
        '교육위원회': ['교육', '학생', '학교', '대학'],
        '보건복지위원회': ['복지', '의료', '건강', '연금'],
        '국토교통위원회': ['교통', '주거', '도로', '건설'],
        '환경노동위원회': ['환경', '노동', '일자리'],
        '여성가족위원회': ['여성', '가족', '육아', '출산']
      };

      const keywords = committeeKeywords[committee] || [];
      return keywords.some(keyword => topicLower.includes(keyword));
    });

    if (relevantCommittees.length > 0) {
      result.committees = relevantCommittees;
    }
  }

  // 지역 연고 (지역현안에서 관련성 높음)
  if (category === 'local-issues' || topicLower.includes('지역') || topicLower.includes('우리 동네')) {
    if (userProfile.localConnection) {
      const connectionMap = {
        '토박이': '지역 토박이로서',
        '오래 거주': '오랫동안 이 지역에 거주해',
        '이주민': '이 지역에서 새로운 삶을 시작한 고향으로 일구',
        '귀농': '고향으로 돌아온'
      };
      result.connection = connectionMap[userProfile.localConnection];
    }
  }

  return result;
}

// 간단한 응답 헬퍼
const ok = (data) => ({ success: true, ...data });
const okMessage = (message) => ({ success: true, message });

// 사용자 포스트 목록 조회
exports.getUserPosts = wrap(async (req) => {
  const { uid } = await auth(req);
  console.log('POST getUserPosts 시작:', { userId: uid });

  try {
    const postsSnapshot = await db.collection('posts')
      .where('userId', '==', uid)
      .orderBy('createdAt', 'desc')
      .limit(50)
      .get();

    const posts = [];
    postsSnapshot.forEach(doc => {
      const data = doc.data();
      // draft 상태가 아닌 포스트만 포함 (클라이언트 필터링)
      if (data.status !== 'draft') {
        posts.push({
          id: doc.id,
          ...data,
          createdAt: data.createdAt?.toDate?.()?.toISOString() || null,
          updatedAt: data.updatedAt?.toDate?.()?.toISOString() || null
        });
      }
    });

    console.log('POST getUserPosts 완료:', { count: posts.length });
    return ok({ posts });
  } catch (error) {
    console.error('POST getUserPosts 오류:', error.message);
    throw new HttpsError('internal', '포스트 목록을 불러오는데 실패했습니다.');
  }
});

// 특정 포스트 조회
exports.getPost = wrap(async (req) => {
  const { uid } = await auth(req);
  const { postId } = req.data || {};
  console.log('POST getPost 시작:', { userId: uid, postId });

  if (!postId) {
    throw new HttpsError('invalid-argument', '포스트 ID를 입력해주세요.');
  }

  try {
    const postDoc = await db.collection('posts').doc(postId).get();
    if (!postDoc.exists) {
      throw new HttpsError('not-found', '포스트를 찾을 수 없습니다.');
    }

    const data = postDoc.data();
    if (data.userId !== uid) {
      throw new HttpsError('permission-denied', '포스트를 조회할 권한이 없습니다.');
    }

    const post = {
      id: postDoc.id,
      ...data,
      createdAt: data.createdAt?.toDate?.()?.toISOString() || null,
      updatedAt: data.updatedAt?.toDate?.()?.toISOString() || null
    };

    console.log('POST getPost 완료:', postId);
    return ok({ post });
  } catch (error) {
    if (error.code) throw error;
    console.error('POST getPost 오류:', error.message);
    throw new HttpsError('internal', '포스트를 불러오는데 실패했습니다.');
  }
});

// 포스트 업데이트
exports.updatePost = wrap(async (req) => {
  const { uid } = await auth(req);
  const { postId, updates } = req.data || {};
  console.log('POST updatePost 시작:', { userId: uid, postId });

  if (!postId || !updates) {
    throw new HttpsError('invalid-argument', '포스트 ID와 수정 데이터를 입력해주세요.');
  }

  try {
    const postDoc = await db.collection('posts').doc(postId).get();
    if (!postDoc.exists) {
      throw new HttpsError('not-found', '포스트를 찾을 수 없습니다.');
    }

    const current = postDoc.data() || {};
    if (current.userId !== uid) {
      throw new HttpsError('permission-denied', '포스트를 수정할 권한이 없습니다.');
    }

    const allowed = ['title', 'content', 'category', 'subCategory', 'keywords', 'status'];
    const sanitized = {};
    for (const k of allowed) {
      if (updates[k] !== undefined) sanitized[k] = updates[k];
    }

    if (sanitized.content) {
      sanitized.wordCount = String(sanitized.content).replace(/<[^>]*>/g, '').replace(/\s/g, '').length;
    }
    sanitized.updatedAt = admin.firestore.FieldValue.serverTimestamp();

    await db.collection('posts').doc(postId).update(sanitized);
    console.log('POST updatePost 완료:', postId);
    return okMessage('포스트가 성공적으로 수정되었습니다');
  } catch (error) {
    if (error.code) throw error;
    console.error('POST updatePost 오류:', error.message);
    throw new HttpsError('internal', '포스트 수정에 실패했습니다.');
  }
});

// 포스트 삭제
exports.deletePost = wrap(async (req) => {
  const { uid } = await auth(req);
  const { postId } = req.data || {};
  console.log('POST deletePost 시작:', { userId: uid, postId });

  if (!postId) {
    throw new HttpsError('invalid-argument', '포스트 ID를 입력해주세요.');
  }

  try {
    const postDoc = await db.collection('posts').doc(postId).get();
    if (!postDoc.exists) {
      throw new HttpsError('not-found', '포스트를 찾을 수 없습니다.');
    }

    const data = postDoc.data() || {};
    if (data.userId !== uid) {
      throw new HttpsError('permission-denied', '포스트를 삭제할 권한이 없습니다.');
    }

    await db.collection('posts').doc(postId).delete();
    console.log('POST deletePost 완료:', postId);
    return okMessage('포스트가 성공적으로 삭제되었습니다');
  } catch (error) {
    if (error.code) throw error;
    console.error('POST deletePost 오류:', error.message);
    throw new HttpsError('internal', '포스트 삭제에 실패했습니다.');
  }
});

// 사용량 제한 체크
exports.checkUsageLimit = wrap(async (req) => {
  const { uid } = await auth(req);
  console.log('USAGE checkUsageLimit 시작:', { userId: uid });

  try {
    const now = new Date();
    const thisMonth = new Date(now.getFullYear(), now.getMonth(), 1);

    const snap = await db.collection('posts')
      .where('userId', '==', uid)
      .where('createdAt', '>=', admin.firestore.Timestamp.fromDate(thisMonth))
      .get();

    const used = snap.size;
    const limit = 50;

    console.log('USAGE checkUsageLimit 완료:', { used, limit });
    return ok({
      postsGenerated: used,
      monthlyLimit: limit,
      canGenerate: used < limit,
      remainingPosts: Math.max(0, limit - used),
    });
  } catch (error) {
    console.error('USAGE 오류:', error.message);
    if (error.code === 'failed-precondition') {
      return ok({
        postsGenerated: 0,
        monthlyLimit: 50,
        canGenerate: true,
        remainingPosts: 50
      });
    }
    throw new HttpsError('internal', '사용량을 확인하는데 실패했습니다.');
  }
});

// 진짜 AI 원고 생성 함수 (백업에서 복구) - HTTP 버전

/**
 * 본문 내용을 기반으로 제목을 생성하는 함수
 * @param {Object} params - 제목 생성에 필요한 파라미터
 * @param {string} params.content - 생성된 본문 내용
 * @param {string|Array} params.backgroundInfo - 배경정보
 * @param {Array} params.keywords - 키워드 목록
 * @param {string} params.topic - 주제
 * @param {string} params.fullName - 작성자 이름
 * @param {string} params.modelName - 사용할 AI 모델명
 * @returns {Promise<string>} - 생성된 제목
 */
async function generateTitleFromContent({ content, backgroundInfo, keywords, topic, fullName, modelName }) {
  console.log('📝 2단계: 본문 기반 제목 생성 시작');

  // 본문에서 HTML 태그 제거하고 미리보기 추출
  const contentPreview = content.substring(0, 1000).replace(/<[^>]*>/g, '');

  // 배경정보 텍스트 추출
  const backgroundText = Array.isArray(backgroundInfo)
    ? backgroundInfo.filter(item => item && item.trim()).join('\n')
    : backgroundInfo || '';

  // 분리된 프롬프트 빌더 사용
  const titlePrompt = buildTitlePrompt({
    contentPreview,
    backgroundText,
    topic,
    fullName,
    keywords
  });

  try {
    const titleResponse = await callGenerativeModel(titlePrompt, 1, modelName);

    // JSON이나 코드 블록 제거
    let cleanTitle = titleResponse
      .replace(/```json/g, '')
      .replace(/```/g, '')
      .trim();

    // 첫 번째 줄만 추출 (여러 줄인 경우)
    cleanTitle = cleanTitle.split('\n')[0].trim();

    // 따옴표 제거
    cleanTitle = cleanTitle.replace(/^["']|["']$/g, '');

    console.log('✅ 제목 생성 완료:', cleanTitle);
    return cleanTitle;
  } catch (error) {
    console.error('❌ 제목 생성 실패:', error.message);
    // 실패 시 기본 제목 반환
    return `${topic} 관련 원고`;
  }
}


exports.generatePosts = httpWrap(async (req) => {
  console.log('🔥 generatePosts HTTP 시작');

  let uid;
  let decodedToken = null;

  // 데이터 추출 - Firebase SDK와 HTTP 요청 모두 처리
  let requestData = req.data || req.rawRequest?.body || {};

  // 중첩된 data 구조 처리 (Firebase SDK에서 {data: {실제데이터}} 형태로 보낼 때)
  if (requestData.data && typeof requestData.data === 'object') {
    requestData = requestData.data;
  }

  // 사용자 인증 데이터 확인 (모든 사용자는 네이버 로그인)
  if (requestData.__naverAuth && requestData.__naverAuth.uid && requestData.__naverAuth.provider === 'naver') {
    console.log('📱 사용자 인증 처리:', requestData.__naverAuth.uid);
    uid = requestData.__naverAuth.uid;
    // 인증 정보 제거 (처리 완료)
    delete requestData.__naverAuth;
  } else {
    const authHeader = (req.rawRequest && (req.rawRequest.headers.authorization || req.rawRequest.headers.Authorization)) || '';
    if (authHeader && authHeader.startsWith('Bearer ')) {
      const idToken = authHeader.split('Bearer ')[1];
      try {
        const verified = await admin.auth().verifyIdToken(idToken);
        uid = verified.uid;
      } catch (authError) {
        console.error('ID token verify failed:', authError);
        throw new HttpsError('unauthenticated', '유효하지 않은 인증 토큰입니다.');
      }
    } else {
      console.error('인증 정보 누락:', requestData);
      throw new HttpsError('unauthenticated', '인증이 필요합니다.');
    }
  }

  console.log('✅ 사용자 인증 완료:', uid);

  console.log('🔍 전체 요청 구조:', JSON.stringify({
    data: req.data,
    body: req.rawRequest?.body,
    method: req.rawRequest?.method,
    headers: req.rawRequest?.headers
  }, null, 2));

  // 데이터는 이미 위에서 추출했으므로 requestData 변수 사용
  const useBonus = requestData?.useBonus || false;

  // 이제 data를 requestData로 할당
  const data = requestData;

  console.log('🔥 generatePosts 시작 (실제 AI 생성) - 받은 데이터', JSON.stringify(data, null, 2));

  // prompt 필드 우선 처리
  const topic = data.prompt || data.topic || '';
  const category = data.category || '';
  const modelName = data.modelName || 'gemini-2.0-flash-exp'; // 기본값은 2.0-flash (JSON mode 지원)
  const targetWordCount = data.wordCount || 1700; // 사용자 요청 글자수 (기본값 1700)

  console.log('🔍 검증 중', {
    topic: topic ? topic.substring(0, 50) : topic,
    category,
    modelName,
    rawPrompt: data.prompt,
    rawTopic: data.topic,
    fullTopic: topic
  });
  if (!topic || typeof topic !== 'string' || topic.trim().length === 0) {
    console.error('❌ 주제 검증 실패:', { topic, type: typeof topic });
    throw new HttpsError('invalid-argument', '주제를 입력해주세요.');
  }

  if (!category || typeof category !== 'string' || category.trim().length === 0) {
    console.error('❌ 카테고리 검증 실패:', { category, type: typeof category });
    throw new HttpsError('invalid-argument', '카테고리를 선택해주세요.');
  }

  console.log(`✅ 데이터 검증 통과: 주제="${topic.substring(0, 50)}..." 카테고리="${category}"`);

  try {
    // 사용자 프로필 및 Bio 메타데이터 가져오기
    let userProfile = {};
    let bioMetadata = null;
    let personalizedHints = '';
    let dailyLimitWarning = false;
    let userMetadata = null; // 향상된 메타데이터 (스코프 버그 수정)

    try {
      // 사용자 기본 정보 조회
      console.log(`🔍 프로필 조회 시도 - UID: ${uid}, 길이: ${uid?.length}`);
      const userDoc = await Promise.race([
        db.collection('users').doc(uid).get(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('프로필 조회 타임아웃')), 5000))
      ]);

      console.log(`📋 프로필 문서 존재 여부: ${userDoc.exists}`);
      if (userDoc.exists) {
        userProfile = userDoc.data();
        console.log('✅ 사용자 프로필 조회 완료:', userProfile.name || 'Unknown');

        // 하루 생성량 제한 확인 (관리자는 제한 없음)
        const isAdmin = userProfile.isAdmin === true;

        if (!isAdmin) {
          // 일반 사용자 하루 3회 초과 시 경고 (차단하지는 않음)
          const today = new Date();
          const todayKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
          const dailyUsage = userProfile.dailyUsage || {};
          const todayGenerated = dailyUsage[todayKey] || 0;

          if (todayGenerated >= 3) {
            console.log('⚠️ 하루 3회 초과 생성 - 경고만 표시');
            dailyLimitWarning = true;
            // 차단하지 않고 계속 진행 (경고 메시지만 응답에 포함)
          }

          console.log('✅ 일반 사용자 하루 사용량 확인:', { todayGenerated, warning: todayGenerated >= 3 });
        } else {
          console.log('✅ 관리자 계정 - 하루 생성량 제한 무시');
        }

        // 보너스 사용 여부에 따른 사용 가능 여부 확인
        if (useBonus) {
          const usage = userProfile.usage || { bonusGenerated: 0, bonusUsed: 0 };
          const availableBonus = Math.max(0, usage.bonusGenerated - (usage.bonusUsed || 0));

          if (availableBonus <= 0) {
            throw new HttpsError('failed-precondition', '사용 가능한 보너스 원고가 없습니다.');
          }

          console.log('✅ 보너스 원고 사용 가능', { availableBonus });
        } else {
          // 일반 사용량 확인 (관리자는 제한 없음)
          if (!isAdmin) {
            const usage = userProfile.usage || { postsGenerated: 0, monthlyLimit: 50 };

            if (usage.postsGenerated >= usage.monthlyLimit) {
              throw new HttpsError('resource-exhausted', '월간 생성 시도를 초과했습니다.');
            }

            console.log('✅ 일반 원고 생성 가능', {
              current: usage.postsGenerated,
              limit: usage.monthlyLimit
            });
          } else {
            console.log('✅ 관리자 계정 - 월간 생성량 제한 무시');
          }
        }
      }

      // Bio 메타데이터 조회 (선택적)
      console.log(`🔍 Bio 메타데이터 조회 시도 - UID: ${uid}`);
      const bioDoc = await db.collection('bios').doc(uid).get();
      console.log(`📋 Bio 문서 존재 여부: ${bioDoc.exists}`);
      if (bioDoc.exists && bioDoc.data().extractedMetadata) {
        bioMetadata = bioDoc.data().extractedMetadata;

        // 메타데이터 기반 개인화 힌트 생성
        personalizedHints = generatePersonalizedHints(bioMetadata);
        console.log('✅ Bio 메타데이터 사용:', Object.keys(bioMetadata));

        // Bio 사용 통계 업데이트
        await db.collection('bios').doc(uid).update({
          'usage.generatedPostsCount': admin.firestore.FieldValue.increment(1),
          'usage.lastUsedAt': admin.firestore.FieldValue.serverTimestamp()
        });
      }

      // 개인정보 기반 페르소나 힌트 생성 및 추가
      const personaHints = generatePersonaHints(userProfile, category, topic);
      if (personaHints) {
        personalizedHints = personalizedHints ? `${personalizedHints} | ${personaHints}` : personaHints;
        console.log('✅ 페르소나 힌트 추가:', personaHints);
      }

      // Bio 메타데이터 로드 (향상된 개인화를 위해)
      try {
        const bioDoc = await db.collection('bios').doc(uid).get();

        if (bioDoc.exists && bioDoc.data().metadataStatus === 'completed') {
          const bioData = bioDoc.data();

          userMetadata = {
            extractedMetadata: bioData.extractedMetadata,
            typeMetadata: bioData.typeMetadata?.[category],
            hints: bioData.optimizationHints
          };

          console.log('✅ 향상된 메타데이터 로드 완료:', uid);
        }
      } catch (metaError) {
        console.warn('⚠️ 메타데이터 로드 실패 (무시하고 계속):', metaError.message);
      }

      // 향상된 메타데이터 힌트 추가
      const enhancedHints = generateEnhancedMetadataHints(userMetadata, category);
      if (enhancedHints) {
        personalizedHints = personalizedHints ? `${personalizedHints} | ${enhancedHints}` : enhancedHints;
        console.log('✅ 향상된 메타데이터 힌트 추가:', enhancedHints);
      }

    } catch (profileError) {
      console.error('❌ 프로필/Bio 조회 실패:', {
        error: profileError.message,
        stack: profileError.stack,
        uid: uid,
        uidType: typeof uid,
        uidLength: uid?.length
      });

      // 프로필이 없어도 계속 진행 (기본값 사용)
      throw new HttpsError('internal', `프로필 조회 실패: ${profileError.message}`);
    }

    // 사용자 상태에 따른 글 설정 및 호칭 결정
    const statusConfig = {
      '현역': {
        guideline: '현역 의원으로서 경험과 성과를 바탕으로 신뢰있는 내용을 포함하세요. 실제 의정활동 경험을 언급하는게 좋습니다.',
        title: userProfile.position || '의원'
      },
      '예비': {
        guideline: '예비후보로서 정책과 공약을 중심으로 신뢰있는 내용을 작성하세요. 미래 비전과 구체적 계획을 제시하세요',
        title: `${userProfile.position || ''}예비후보`.replace('의원예비후보', '예비후보')
      },
      '은퇴': {
        guideline: '은퇴 상태에서는 어떤 호칭도 사용하지 않고 개인 이름으로만 지칭하세요. 현상 진단과 개인적 견해만 표현하세요. 절대 "은퇴예비후보", "예비후보", "의원", "현역 의원으로서", "의정활동", "성과", "실적", "추진함", "기여함" 같은 표현을 사용하지 마세요. 구체적인 비전이나 계획을 언급하지 마세요. 오직 현 상황에 대한 개인적 경험과 진단만 표현하세요',
        title: '' // 은퇴 상태에서는 호칭 없음
      }
    };

    const currentStatus = userProfile.status || '현역';
    const config = statusConfig[currentStatus] || statusConfig['현역'];

    // 프롬프트 생성
    const fullName = userProfile.name || '사용자';
    // 자연스러운 지역명 호칭 생성 (모두 붙여쓰기)
    const generateNaturalRegionTitle = (regionLocal, regionMetro) => {
      // 기본 지역이 없으면 빈 문자열
      if (!regionLocal && !regionMetro) return '';

      // 우선순위: regionLocal > regionMetro
      const primaryRegion = regionLocal || regionMetro;

      // 광역시 단위: XX광역시, XX구도
      if (primaryRegion.includes('광역시') || primaryRegion.includes('구도')) {
        return primaryRegion + '민';
      }

      // 도 단위: XX도
      if (primaryRegion.includes('도')) {
        return primaryRegion + '민';
      }

      // 시 단위: XX시
      if (primaryRegion.includes('시')) {
        return primaryRegion + '민';
      }

      // 기타인 경우 기본으로 처리
      return primaryRegion + '도민';
    };

    const fullRegion = generateNaturalRegionTitle(userProfile.regionLocal, userProfile.regionMetro);


    // 뉴스 컨텍스트 조회 (시사비평, 정책제안 등 특정 카테고리만) - AI 압축 적용
    let newsContext = '';
    if (shouldFetchNews(category)) {
      try {
        console.log('📰 뉴스 컨텍스트 조회 시작:', topic);
        const news = await fetchNaverNews(topic, 3);
        if (news && news.length > 0) {
          // AI 압축 적용 (토큰 80% 절감)
          const compressedNews = await compressNewsWithAI(news);
          newsContext = formatNewsForPrompt(compressedNews);
          console.log(`✅ 뉴스 ${news.length}개 압축 완료`);
        }
      } catch (newsError) {
        console.warn('⚠️ 뉴스 조회 실패 (무시하고 계속):', newsError.message);
        // 뉴스 조회 실패해도 원고 생성은 계속 진행
      }
    }


    // 배경정보에서 필수 키워드 추출 (검증용)
    function extractKeywordsFromInstructions(instructions) {
      if (!instructions) return [];

      const text = Array.isArray(instructions) ? instructions.join(' ') : instructions;
      const keywords = [];

      // 1. 숫자+단위 추출 (예: 300여명, 500명, 1000개, 2회)
      const numberMatches = text.match(/[0-9]+여?[명개회건차명월일년원]/g);
      if (numberMatches) keywords.push(...numberMatches);

      // 2. 인명 + 직책 패턴 (예: 홍길동 의원, 김철수 위원장, 홍길동 경기도당위원장)
      // 첫 번째 패턴: 직책이 바로 붙거나 공백 후 나오는 경우
      const nameWithTitleMatches = text.match(/[가-힣]{2,4}\s+(?:경기도당위원장|국회의원|위원장|의원|시장|도지사|장관|총리|대통령)/g);
      if (nameWithTitleMatches) {
        keywords.push(...nameWithTitleMatches);
        // 이름만 별도 추출 (검증 시 부분 매칭용)
        nameWithTitleMatches.forEach(match => {
          const nameOnly = match.match(/([가-힣]{2,4})\s+/);
          if (nameOnly && nameOnly[1]) keywords.push(nameOnly[1]);
        });
      }

      // 3. 조직명 패턴 (예: 경기도당, 서울시당, 교육위원회)
      const orgMatches = text.match(/[가-힣]{2,}(?:도당|시당|구당|위원회|재단|협회|연합|위원회)/g);
      if (orgMatches) keywords.push(...orgMatches);

      // 4. 이벤트명 패턴 (예: 체육대회, 토론회, 간담회)
      const eventMatches = text.match(/[가-힣]{2,}(?:대회|행사|토론회|간담회|설명회|세미나|워크숍|회의|집회|축제)/g);
      if (eventMatches) keywords.push(...eventMatches);

      // 5. 지명 패턴 (예: 서울특별시, 경기도, 수원시)
      const placeMatches = text.match(/[가-힣]{2,}(?:특별시|광역시|도|시|군|구|읍|면|동)/g);
      if (placeMatches) keywords.push(...placeMatches);

      // 6. 연도/날짜 (예: 2024년, 2025년)
      const yearMatches = text.match(/20[0-9]{2}년/g);
      if (yearMatches) keywords.push(...yearMatches);

      // 7. 정책/법안명 (예: OO법, OO정책, OO사업)
      const policyMatches = text.match(/[가-힣]{2,}(?:법|조례|정책|사업|계획|방안)/g);
      if (policyMatches) keywords.push(...policyMatches);

      // 중복 제거 및 반환
      return [...new Set(keywords)];
    }

    const backgroundKeywords = extractKeywordsFromInstructions(data.instructions);
    console.log('🔍 배경정보 필수 키워드:', backgroundKeywords);

    // 카테고리를 작법(writingMethod)으로 매핑
    const categoryToWritingMethod = {
      'daily-communication': 'emotional_writing',
      'activity-report': 'direct_writing',
      'policy-proposal': 'logical_writing',
      'current-affairs': 'critical_writing',
      'local-issues': 'analytical_writing'
    };
    const writingMethod = categoryToWritingMethod[category] || 'emotional_writing';

    // buildSmartPrompt 사용 (카테고리별 특화 프롬프트)
    const prompt = await buildSmartPrompt({
      writingMethod,
      topic,
      authorBio: `${fullName} (${config.title || ''}, ${fullRegion || ''})`,
      targetWordCount,
      instructions: data.instructions,
      keywords: backgroundKeywords,
      newsContext,
      personalizedHints,
      applyEditorialRules: true
    });


    console.log(`🔥 AI 호출 시작 (1개 원고 생성) - 모델: ${modelName}...`);

    // 최대 3번 시도 (검증 실패 시 재시도)
    let apiResponse;
    let attempt = 0;
    const maxAttempts = 3;

    while (attempt < maxAttempts) {
      attempt++;
      console.log(`🔥 AI 호출 시도 ${attempt}/${maxAttempts}...`);

      apiResponse = await callGenerativeModel(prompt, 1, modelName);

      // 기본 검증
      if (apiResponse && apiResponse.length > 100) {
        // JSON 파싱하여 실제 content 추출
        let contentToCheck = apiResponse;
        try {
          const jsonMatch = apiResponse.match(/```json\s*([\s\S]*?)\s*```/) ||
                           apiResponse.match(/\{[\s\S]*?\}/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[1] || jsonMatch[0]);
            contentToCheck = parsed.content || apiResponse;
          }
        } catch (e) {
          // JSON 파싱 실패시 원본 사용
        }

        // HTML 태그 제거하고 순수 텍스트 길이 계산 (공백 제외)
        const plainText = contentToCheck.replace(/<[^>]*>/g, '').replace(/\s/g, '');
        const actualWordCount = plainText.length;
        const minWordCount = Math.floor(targetWordCount * 0.9); // 목표의 90%

        console.log(`📊 분량 체크 - 실제: ${actualWordCount}자, 목표: ${targetWordCount}자, 최소: ${minWordCount}자`);

        // 중요한 내용이 포함되어 있는지 검증
        const hasName = apiResponse.includes(fullName);
        const hasRegion = fullRegion ? apiResponse.includes(fullRegion) : true;
        const hasSufficientLength = actualWordCount >= minWordCount;

        console.log(`🔍 검증 결과 - 이름: ${hasName}, 지역: ${hasRegion}, 분량충족: ${hasSufficientLength}`);

        if (hasName && hasRegion && hasSufficientLength) {
          console.log(`✅ 모든 검증 통과! (${attempt}번째 시도)`);
          break;
        }

        if (attempt < maxAttempts) {
          if (!hasSufficientLength) {
            console.log(`⚠️ 분량 부족 (${actualWordCount}/${minWordCount}자) - 재생성 필요`);
            // 분량 부족을 명시적으로 프롬프트에 추가하여 재시도
            prompt = prompt + `\n\n**중요: 반드시 ${targetWordCount}자 이상으로 작성하세요.**`;
          } else {
            console.log(`❌ 기타 검증 실패 - 재시도 필요`);
          }
          continue;
        }
      }

      if (attempt >= maxAttempts) {
        console.log(`⚠️ 최대 시도 횟수 초과 - 현재 응답 사용`);
      }
    }


    console.log(`✅ AI 응답 최종 수신, 길이: ${apiResponse.length} - 모델: ${modelName}`);

    // JSON 파싱
    let parsedResponse;
    try {
      // JSON 블록 추출
      const jsonMatch = apiResponse.match(/```json\s*([\s\S]*?)\s*```/) ||
                       apiResponse.match(/\{[\s\S]*?\}/);

      if (jsonMatch) {
        const jsonText = jsonMatch[1] || jsonMatch[0];
        console.log('🔍 추출된 JSON 일부:', jsonText.substring(0, 200));
        parsedResponse = JSON.parse(jsonText);
        console.log('✅ JSON 파싱 완료, 제목:', parsedResponse.title);
      } else {
        throw new Error('JSON 형식 찾기 실패');
      }
    } catch (parseError) {
      console.error('❌ JSON 파싱 실패:', parseError.message);
      console.error('응답 내용:', apiResponse.substring(0, 500));

      // 파싱 실패 시 기본 구조 생성
      parsedResponse = {
        title: `${topic} 관련 원고`,
        content: `<p>${topic}에 대한 의견을 나누고자 합니다.</p><p>구체적인 내용은 AI 응답 파싱에 실패했습니다.</p>`,
        wordCount: 100
      };
    }

    // 🔧 강제 후처리: AI가 무시한 필수 정보들을 직접 수정
    console.log('🔩 후처리 시작 - 필수 정보 강제 삽입');

    if (parsedResponse && parsedResponse.content) {
      let fixedContent = parsedResponse.content;

      // 1. 기본적인 호칭 수정
      fixedContent = fixedContent.replace(/의원입니다/g, `${fullName}입니다`);
      fixedContent = fixedContent.replace(/의원으로서/g, `${config.title}으로서`);
      fixedContent = fixedContent.replace(/국회 의원/g, config.title);
      fixedContent = fixedContent.replace(/\s의원\s/g, ` ${config.title} `);

      // 은퇴 상태 특별 수정 - 모든 호칭과 공약 활동 표현 제거
      if (currentStatus === '은퇴') {
        // 모든 호칭 제거 (첫 인사 이후)
        fixedContent = fixedContent.replace(/은퇴예비후보/g, '저');
        fixedContent = fixedContent.replace(/예비후보/g, '저');
        fixedContent = fixedContent.replace(/의원으로서/g, '저로서');
        fixedContent = fixedContent.replace(/은퇴.*예비후보.*로서/g, '저로서');

        // 공약/정치 활동 표현 제거
        fixedContent = fixedContent.replace(/의정활동을 통해/g, '제 경험과의 소통을 통해');
        fixedContent = fixedContent.replace(/현역 의원으로서/g, '저로서');
        fixedContent = fixedContent.replace(/성과를/g, '경험을');
        fixedContent = fixedContent.replace(/실적을/g, '활동을');
        fixedContent = fixedContent.replace(/추진하겠습니다/g, '생각합니다');
        fixedContent = fixedContent.replace(/기여하겠습니다/g, '관심을 갖고 있습니다');

        // 3인칭을 1인칭 변경 (첫 인사 이후)
        // "강정구는" -> "저는" (단 첫 인사 문장은 제외)
        const sentences = fixedContent.split('</p>');
        for (let i = 1; i < sentences.length; i++) { // 첫번째 문단(인사) 이후부터 적용
          sentences[i] = sentences[i].replace(new RegExp(`${fullName}는`, 'g'), '저는');
          sentences[i] = sentences[i].replace(new RegExp(`${fullName}가`, 'g'), '제가');
          sentences[i] = sentences[i].replace(new RegExp(`${fullName}를`, 'g'), '저를');
          sentences[i] = sentences[i].replace(new RegExp(`${fullName}의`, 'g'), '저의');
        }
        fixedContent = sentences.join('</p>');

        // 마지막 형식 마무리/인사 완전 제거
        fixedContent = fixedContent.replace(new RegExp(`${fullName} 드림`, 'g'), '');
        fixedContent = fixedContent.replace(/드림<\/p>/g, '</p>');
        fixedContent = fixedContent.replace(/<p>드림<\/p>/g, '');
        fixedContent = fixedContent.replace(/\n\n드림$/g, '');
        fixedContent = fixedContent.replace(/드림$/g, '');
        fixedContent = fixedContent.replace(/올림<\/p>/g, '</p>');
        fixedContent = fixedContent.replace(/<p>올림<\/p>/g, '');

        // 이상한 지역 표현 수정
        const regionName = userProfile.regionLocal || userProfile.regionMetro || '양양군시';
        const baseRegion = regionName.replace('도민', '').replace('민', '');
        fixedContent = fixedContent.replace(new RegExp(`${baseRegion}도민 경제`, 'g'), `${baseRegion} 경제`);
        fixedContent = fixedContent.replace(new RegExp(`${baseRegion}도민 관광`, 'g'), `${baseRegion} 관광`);
        fixedContent = fixedContent.replace(new RegExp(`${baseRegion}도민 발전`, 'g'), `${baseRegion} 발전`);

        // 중복/이상한 표현 정리
        fixedContent = fixedContent.replace(/양양군시민을 포함한 많은 군민들/g, '많은 주민들');
        fixedContent = fixedContent.replace(/양양군시민 여러분을 포함한/g, '제 여러분을 포함한');

        // 불완전한 문장 감지 및 제거 (조사가 끝나는 문장)
        fixedContent = fixedContent.replace(/([가-힣]+)\s*<\/p>/g, (match, word) => {
          if (!word.match(/[다요까니다요면네요습것음임음]$/)) {
            // 불완전한 문장으로 보이면 이전 완전한 문장에서 종료
            return '</p>';
          }
          return match;
        });

        // 빈 문단 제거
        fixedContent = fixedContent.replace(/<p><\/p>/g, '');
        fixedContent = fixedContent.replace(/<p>\s*<\/p>/g, '');

        // 이상한 조사 수정
        fixedContent = fixedContent.replace(/양양군을 통해/g, '양양군내를 통해');
        fixedContent = fixedContent.replace(/양양군을/g, '양양군내를');
      }

      // 2. 인사말에 이름 삽입 (중복되지 않도록 조심스럽게)
      // "안녕하세요?"를 "안녕하세요, {이름}입니다"로 변경 (이미 이름이 없는 경우만)
      if (!fixedContent.includes(`저 ${fullName}`)) {
        fixedContent = fixedContent.replace(/(<p>)안녕하세요/g, `$1안녕하세요 ${fullName}입니다`);
      }
      // "안녕 "다음에 이름이 없는 경우만 이름 삽입
      fixedContent = fixedContent.replace(/(<p>)안녕 ([^가-힣])/g, `$1안녕 ${fullName} $2`);

      // 3. 인사말 지역정보 수정
      if (fullRegion) {
        // 구체적인 패턴만 교체
        fixedContent = fixedContent.replace(/우리 지역의/g, `${fullRegion}의`);
        fixedContent = fixedContent.replace(/우리 지역에/g, `${fullRegion}에`);
        fixedContent = fixedContent.replace(/지역의/g, `${fullRegion} `);
        fixedContent = fixedContent.replace(/\s를\s/g, ` ${fullRegion}를`);
        fixedContent = fixedContent.replace(/\s의 발전을/g, ` ${fullRegion}의 발전을`);
        fixedContent = fixedContent.replace(/에서의/g, `${fullRegion}에서의`);

        // 빈 지역 참조 패턴 찾아서 수정
        fixedContent = fixedContent.replace(/,\s*의\s/g, `, ${fullRegion}의`);
        fixedContent = fixedContent.replace(/\s*에서\s*인/g, ` ${fullRegion}에서 인구`);
      }

      // 4. 시작 문장에 호칭를 포함하지 않으면 강제 수정
      if (!fixedContent.includes(`${fullName}입니다`)) {
        // 첫번째 p 태그 찾아서 교체
        fixedContent = fixedContent.replace(/^<p>[^<]*?<\/p>/,
          `<p>존경하는 ${fullRegion} 도민 여러분 ${fullName}입니다.</p>`);
      }

      // 5. 마지막에 서명 수정 (은퇴 상태가 아닐 때만)
      if (currentStatus !== '은퇴') {
        fixedContent = fixedContent.replace(/의원 올림/g, `${fullName} 드림`);
        fixedContent = fixedContent.replace(/의원 드림/g, `${fullName} 드림`);

        // 서명이 없으면 추가
        if (!fixedContent.includes(`${fullName} 드림`) && !fixedContent.includes(`${fullName} 올림`)) {
          fixedContent = fixedContent.replace(/<\/p>$/, `</p><p>${fullName} 드림</p>`);
        }
      }

      // 6. 기타 패턴 수정
      fixedContent = fixedContent.replace(/도민 여러분 의원입니다/g, `도민 여러분 ${fullName}입니다`);
      fixedContent = fixedContent.replace(/여러분께, 의원입니다/g, `여러분께, ${fullName}입니다`);

      // 불완전한 문장 수정
      fixedContent = fixedContent.replace(/행복하겠습니다/g, '행복을 높이겠습니다');
      fixedContent = fixedContent.replace(/도민들의 목소리재현/g, '도민들의 목소리를 듣고 있재현');
      fixedContent = fixedContent.replace(/모두의 소통 미래를/g, '모두의 소통을 채워가며 미래를');

      // 이상한 텍스트 조각 수정
      fixedContent = fixedContent.replace(/양양군시민들이 행복이/g, '양양군시민 여러분을 위해 행복이');
      fixedContent = fixedContent.replace(/불여해서/g, '제 여러분께');
      fixedContent = fixedContent.replace(/([가-힣]+) ([가-힣]+)를 통해/g, (match, word1, word2) => {
        if (word2.includes('군을') || word2.includes('시를')) {
          return `${word1} ${word2.replace('을', '를')} 통해`;
        }
        return match;
      });

      // 🔩 최종 중복 이름 패턴 제거 (모든 처리 완료 후)
      console.log('🔩 최종 중복 이름 제거 시작');
      fixedContent = fixedContent.replace(new RegExp(`안녕 ${fullName} ${fullName}입`, 'g'), `안녕 ${fullName}입`);
      fixedContent = fixedContent.replace(new RegExp(`안녕 ${fullName} ${fullName}가`, 'g'), `안녕 ${fullName}가`);
      fixedContent = fixedContent.replace(new RegExp(`안녕 ${fullName} ${fullName}를`, 'g'), `안녕 ${fullName}를`);
      fixedContent = fixedContent.replace(new RegExp(`안녕 ${fullName} ${fullName}`, 'g'), `안녕 ${fullName}`);
      fixedContent = fixedContent.replace(new RegExp(`${fullName} ${fullName}입`, 'g'), `${fullName}입`);
      fixedContent = fixedContent.replace(new RegExp(`${fullName} ${fullName}가`, 'g'), `${fullName}가`);
      fixedContent = fixedContent.replace(new RegExp(`${fullName} ${fullName}를`, 'g'), `${fullName}를`);
      fixedContent = fixedContent.replace(new RegExp(`${fullName} ${fullName}`, 'g'), fullName);

      // 3연속 이상 중복도 처리
      fixedContent = fixedContent.replace(new RegExp(`${fullName} ${fullName} ${fullName}`, 'g'), fullName);
      fixedContent = fixedContent.replace(new RegExp(`안녕 ${fullName} ${fullName} ${fullName}`, 'g'), `안녕 ${fullName}`);

      parsedResponse.content = fixedContent;
      console.log('✅ 후처리 완료 - 필수 정보 삽입됨');
    }

    // 2단계: 본문 기반 제목 생성
    const generatedTitle = await generateTitleFromContent({
      content: parsedResponse.content || '',
      backgroundInfo: data.instructions,
      keywords: backgroundKeywords,
      topic,
      fullName,
      modelName
    });

    // drafts 형식으로 반환 (프론트엔드 호환성)
    const draftData = {
      id: `draft_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      title: generatedTitle,
      content: parsedResponse.content || `<p>${topic}에 대한 내용입니다.</p>`,
      wordCount: parsedResponse.wordCount || parsedResponse.content?.replace(/<[^>]*>/g, '').length || 0,
      category,
      subCategory: data.subCategory || '',
      keywords: data.keywords || '',
      generatedAt: new Date().toISOString()
    };

    // 사용량 업데이트 (관리자는 카운트하지 않음)
    if (userProfile && Object.keys(userProfile).length > 0) {
      const isAdmin = userProfile.isAdmin === true;

      try {
        if (useBonus) {
          // 보너스 사용량 증가 (하루 사용량도 함께 증가)
          const today = new Date();
          const todayKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

          await db.collection('users').doc(uid).update({
            'usage.bonusUsed': admin.firestore.FieldValue.increment(1),
            [`dailyUsage.${todayKey}`]: isAdmin ? 0 : admin.firestore.FieldValue.increment(1), // 관리자는 하루 카운트 제외
            lastBonusUsed: admin.firestore.FieldValue.serverTimestamp()
          });
          console.log('✅ 보너스 원고 사용량 업데이트', isAdmin ? '(관리자 - 하루 카운트 제외)' : '');
        } else {
          // 일반 사용량 증가 (관리자는 카운트하지 않음)
          if (!isAdmin) {
            const today = new Date();
            const todayKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

            await db.collection('users').doc(uid).update({
              'usage.postsGenerated': admin.firestore.FieldValue.increment(1),
              [`dailyUsage.${todayKey}`]: admin.firestore.FieldValue.increment(1),
              lastGenerated: admin.firestore.FieldValue.serverTimestamp()
            });
            console.log('✅ 일반 원고 사용량 및 하루 사용량 업데이트');
          } else {
            // 관리자는 사용량 카운트하지 않음 (생성 기록만 저장)
            await db.collection('users').doc(uid).update({
              lastGenerated: admin.firestore.FieldValue.serverTimestamp()
            });
            console.log('✅ 관리자 계정 - 사용량 카운트 없이 기록만 업데이트');
          }
        }
      } catch (updateError) {
        console.warn('⚠️ 사용량 업데이트 실패:', updateError.message);
      }
    }

    console.log('✅ generatePosts 완료:', {
      title: draftData.title,
      wordCount: draftData.wordCount,
      useBonus
    });

    // 경고 메시지 생성
    let message = useBonus ? '보너스 원고가 성공적으로 생성되었습니다' : '원고가 성공적으로 생성되었습니다';
    if (dailyLimitWarning) {
      message += '\n\n⚠️ 하루 3회 이상 원고를 생성하셨습니다. 네이버 블로그 정책상 과도한 발행은 스팸으로 분류될 수 있으므로, 반드시 마지막 포스팅으로부터 3시간 경과 후 발행해 주세요';
    }

    return ok({
      success: true,
      message: message,
      dailyLimitWarning: dailyLimitWarning,
      drafts: draftData,
      metadata: {
        generatedAt: new Date().toISOString(),
        userId: uid,
        processingTime: Date.now(),
        usedBonus: useBonus
      }
    });

  } catch (error) {
    console.error('❌ generatePosts 오류:', error.message);
    throw new HttpsError('internal', '원고 생성에 실패했습니다: ' + error.message);
  }
});


// saveSelectedPost - 선택된 원고 저장
exports.saveSelectedPost = httpWrap(async (req) => {
  let uid;

  // 데이터 추출 - Firebase SDK와 HTTP 요청 모두 처리
  let requestData = req.data || req.rawRequest?.body || {};

  // 중첩된 data 구조 처리
  if (requestData.data && typeof requestData.data === 'object') {
    requestData = requestData.data;
  }

  // 사용자 인증 데이터 확인 (모든 사용자는 네이버 로그인)
  if (requestData.__naverAuth && requestData.__naverAuth.uid && requestData.__naverAuth.provider === 'naver') {
    console.log('📱 사용자 인증 처리:', requestData.__naverAuth.uid);
    uid = requestData.__naverAuth.uid;
    // 인증 정보 제거 (처리 완료)
    delete requestData.__naverAuth;
  } else {
    const authHeader = (req.rawRequest && (req.rawRequest.headers.authorization || req.rawRequest.headers.Authorization)) || '';
    if (authHeader && authHeader.startsWith('Bearer ')) {
      const idToken = authHeader.split('Bearer ')[1];
      try {
        const verified = await admin.auth().verifyIdToken(idToken);
        uid = verified.uid;
      } catch (authError) {
        console.error('ID token verify failed:', authError);
        throw new HttpsError('unauthenticated', '유효하지 않은 인증 토큰입니다.');
      }
    } else {
      console.error('인증 정보 누락:', requestData);
      throw new HttpsError('unauthenticated', '인증이 필요합니다.');
    }
  }

  const data = requestData;

  console.log('POST saveSelectedPost 시작:', { userId: uid, data });

  if (!data.title || !data.content) {
    throw new HttpsError('invalid-argument', '제목과 내용이 필요합니다');
  }

  try {
    const wordCount = data.content.replace(/<[^>]*>/g, '').length;

    const postData = {
      userId: uid,
      title: data.title,
      content: data.content,
      category: data.category || '일반',
      subCategory: data.subCategory || '',
      keywords: data.keywords || '',
      wordCount,
      status: 'published',
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };

    const docRef = await db.collection('posts').add(postData);

    console.log('POST saveSelectedPost 완료:', { postId: docRef.id, wordCount });

    return ok({
      success: true,
      message: '원고가 성공적으로 저장되었습니다.',
      postId: docRef.id
    });

  } catch (error) {
    console.error('POST saveSelectedPost 오류:', error.message);
    throw new HttpsError('internal', '원고 저장에 실패했습니다.');
  }
});
